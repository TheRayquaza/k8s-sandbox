apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: local-path-provisioner
  namespace: argocd
  annotations:
    argocd.argoproj.io/sync-wave: "0"
spec:
  project: default
  destination:
    name: in-cluster
    namespace: local-path-provisioner

  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
      - CreateNamespace=true
      - ServerSideApply=true

  sources:
  - repoURL: https://charts.containeroo.ch
    chart: local-path-provisioner
    targetRevision: v0.0.34
    helm:
      releaseName: local-path-provisioner
      skipCrds: false
      values: |
        replicaCount: 1
        commonLabels: {}
        namespaceOverride: ""

        image:
          repository: rancher/local-path-provisioner
          tag: v0.0.34
          pullPolicy: IfNotPresent

        helperImage:
          repository: busybox
          tag: "1.36.1"

        defaultSettings:
          registrySecret: ~

        privateRegistry:
          registryUrl: ~
          registryUser: ~
          registryPasswd: ~

        imagePullSecrets: []
        nameOverride: ""
        fullnameOverride: ""

        storageClass:
          create: true
          defaultClass: true
          defaultVolumeType: hostPath
          name: local-path
          reclaimPolicy: Delete
          volumeBindingMode: WaitForFirstConsumer
          allowedTopologies: []
          annotations: {}

        # nodePathMap is the place user can customize where to store the data on each node.
        # 1. If one node is not listed on the nodePathMap, and Kubernetes wants to create volume on it, the paths specified in
        #    DEFAULT_PATH_FOR_NON_LISTED_NODES will be used for provisioning.
        # 2. If one node is listed on the nodePathMap, the specified paths will be used for provisioning.
        #     1. If one node is listed but with paths set to [], the provisioner will refuse to provision on this node.
        #     2. If more than one path was specified, the path would be chosen randomly when provisioning.
        #
        # The configuration must obey following rules:
        # 1. A path must start with /, a.k.a an absolute path.
        # 2. Root directory (/) is prohibited.
        # 3. No duplicate paths allowed for one node.
        # 4. No duplicate node allowed.
        nodePathMap:
          - node: DEFAULT_PATH_FOR_NON_LISTED_NODES
            paths:
              - /opt/local-path-provisioner

        # `sharedFileSystemPath` allows the provisioner to use a filesystem that is mounted on all
        # nodes at the same time. In this case all access modes are supported: `ReadWriteOnce`,
        # `ReadOnlyMany` and `ReadWriteMany` for storage claims. In addition
        # `volumeBindingMode: Immediate` can be used in  StorageClass definition.
        # Please note that `nodePathMap` and `sharedFileSystemPath` are mutually exclusive.
        # If `sharedFileSystemPath` is used, then `nodePathMap` must be set to `[]`.
        # sharedFileSystemPath: ""

        # `storageClassConfigs` allows the provisioner to manage multiple independent storage classes.
        # Each storage class must have a unique name, and contains the same fields as shown above for
        # a single storage class setup, EXCEPT for the provisionerName, which is the same for all
        # storage classes, and name, which is the key of the map.
        # storageClassConfigs: {}
        #   my-storage-class:
        #     storageClass:
        #       create: true
        #       defaultClass: false
        #       defaultVolumeType: hostPath
        #       reclaimPolicy: Delete
        #     sharedFileSystemPath: ""
        #     ## OR
        #     # See above
        #     nodePathMap: []

        podAnnotations: {}

        podSecurityContext: {}
          # runAsNonRoot: true

        hostUsers: true

        securityContext:
          allowPrivilegeEscalation: false
          seccompProfile:
            type: RuntimeDefault
          capabilities:
            drop: ["ALL"]
          runAsUser: 65534
          runAsGroup: 65534
          readOnlyRootFilesystem: true

        resources:
          limits:
            cpu: 100m
            memory: 128Mi
          requests:
            cpu: 100m
            memory: 128Mi

        helperPod:
          resources:
            limits:
              cpu: 100m
              memory: 128Mi
            requests:
              cpu: 100m
              memory: 128Mi

        rbac:
          create: true

        serviceAccount:
          create: true
          name:

        nodeSelector: {}

        tolerations: []

        affinity: {}

        priorityClassName: "system-node-critical"

        podDisruptionBudget:
          enabled: false

        configmap:
          name: local-path-config
          setup: |-
            #!/bin/sh
            set -eu
            mkdir -m 0777 -p "$VOL_DIR"
          teardown: |-
            #!/bin/sh
            set -eu
            rm -rf "$VOL_DIR"
          helperPod:
            # Allows to run the helper pod in another namespace. Uses release namespace by default.
            namespaceOverride: ""
            name: "helper-pod"
            annotations: {}
            tolerations: []
            # Priority class name for the helper pod (defaults to system-node-critical)
            priorityClassName: "system-node-critical"
        # Number of provisioner worker threads to call provision/delete simultaneously.
        # workerThreads: 4

        provisioningRetryCount: 15
        deletionRetryCount: 15
        extraArgs: []
